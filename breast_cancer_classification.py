# -*- coding: utf-8 -*-
"""Breast Cancer Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zf9yxRZPUtG-j3TnBwWW1V15xeT5lwQe

# Breast Cancer Classification

## Important Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler


import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping

import warnings
warnings.filterwarnings('ignore')

"""##Explore Data"""

df=pd.read_csv('/content/data.csv')

df.head()

df.tail()

df.info()

df.describe()

df.shape

df.isna().sum()

df.duplicated().sum()

df['diagnosis'].value_counts()

"""## Preprocessing"""

df.drop(columns=['id','Unnamed: 32'],inplace=True)

filter_data=pd.DataFrame()
for column in df.columns:
    if df[column].dtype=='float64':
        filter_data[column]=df[column]
print(filter_data.info())
for column in filter_data.columns:
    Q1 = filter_data[column].quantile(0.25)
    Q3 = filter_data[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    df[column] = filter_data[(filter_data[column] >= lower_bound) & (filter_data[column] <= upper_bound)][column]

df.dropna(inplace=True)

"""## Modeling"""

x=df.drop('diagnosis',axis=1)

y=df['diagnosis']

encoder = LabelEncoder()
y = encoder.fit_transform(y)

minmax = MinMaxScaler()
x = minmax.fit_transform(x)

x_train, x_, y_train, y_ = train_test_split(x, y, test_size=0.20, random_state=42)
x_valid, x_test, y_valid, y_test = train_test_split(x_, y_, test_size=0.5, random_state=42)

x_train.shape

y_train.shape

x_.shape

y_.shape

x_valid.shape

y_valid.shape

model = Sequential([

    Dense(32, activation='relu', input_dim=30),

    Dense(16, activation='relu'),

    Dense(1, activation='sigmoid')
])

model.compile(optimizer=Adam(learning_rate=0.001),loss='binary_crossentropy',metrics=['accuracy'])

model.summary()

early_stop=EarlyStopping(patience=10)

model.fit(x_train, y_train, epochs=100, validation_data=(x_valid, y_valid),callbacks=early_stop)

model.evaluate(x_train,y_train)

model.evaluate(x_valid,y_valid)

model.evaluate(x_test,y_test)

y_pred = model.predict(x_test)
y_pred_classes = (y_pred > 0.5).astype("int32")

# Confusion matrix
cm = confusion_matrix(y_test, y_pred_classes)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()